---
title: "Issue Grouping"
sidebar_order: 0
redirect_from:
  - /data-management/rollups/
  - /learn/rollups/
  - /data-management/event-grouping/
  - /guides/grouping-and-fingerprints/
  - add last one here
description: "Learn about fingerprints, the grouping algorithm, grouping by stack trace, grouping by exceptions, and fallback grouping. Learn more about how Sentry groups issues together as well as different approaches for updating how events group into issues"
---

All events have a fingerprint. Events with the same fingerprint are grouped together into an issue.

By default, Sentry will run one of our built-in grouping algorithms to generate a fingerprint based on information available within the event such as `stacktrace`, `exception`, and `message`. To extend the default grouping behavior or change it completely, you can use a combination of the following options:

1. In your SDK, using [SDK Fingerprinting](/platform-redirect/?next=/usage/sdk-fingerprinting/). Note that is not supported in WebAssembly.
2. In your project, using [Fingerprint Rules](./fingerprint-rules/)
3. In your project, using [Stack Trace Rules](./stack-trace-rules/)

<Note>

Stack trace rules can work as a combination of both SDK and project settings. As a result, we maintain the documentation in one location.

</Note>

**TO DO - consolidate this content into content above**

**What is a fingerprint?**
A fingerprint is a way to uniquely identify an event. Sentry sets a fingerprint by default for you. Sentry uses its own built-in grouping algorithms to generate a fingerprint based on information available within the event such as a stack trace, exception, and message. Events with the same fingerprint are grouped together.

**Do I need to do anything?** No. A stack trace is used by default if it's available. So if two events have the same stack trace, then they will group into one issue. If you have separate issues that you'd like to group together, then this guide will show you how.

**How do I see the fingerprint?** Open an issue, click the JSON link, and find the _fingerprint_ property. If the default grouping was used, you'll see default written there. If a different grouping was used, you'll see the actual fingerprint value itself.

## Grouping Algorithms

Each time default grouping behavior is modified, Sentry releases it as a new version. As a result, modifications to the default behavior do not affect the grouping of existing issues.

When you create a Sentry project, the most recent version of the grouping algorithm is automatically selected. This ensures that grouping behavior is consistent within a project.

To upgrade an existing project to a new grouping algorithm version, navigate to **Settings > Projects > [project] > Issue Grouping > Upgrade Grouping**. After upgrading to a new grouping algorithm, you will very likely see new groups being created.

All versions consider the `stacktrace`, `exception` and `message`.

### Grouping by Stack Trace

When Sentry detects a stack trace in the event data (either directly or as part of an exception), the grouping is effectively based entirely on the stack trace.

The first and most crucial part is that Sentry only groups by stack trace frames that the SDK reports and associates with your application. Not all SDKs report this, but when that information is provided, itâ€™s used for grouping. This means that if two stack traces differ only in parts of the stack that are unrelated to the application, those stack traces will still be grouped together.

Depending on the information available, the following data can be used for each stack trace frame:

- Module name
- Normalized filename (with revision hashes, and so forth, removed)
- Normalized context line (essentially a cleaned up version of the source code of the affected line, if provided)

This grouping usually works well, but two specific situations can throw it off:

1. Minimized JavaScript source code will destroy the grouping in detrimental ways. To avoid this, ensure that Sentry can access your [Source Maps](/platforms/javascript/sourcemaps/).
2. Modifying your stack trace by introducing a new level through decorators changes your stack trace, so the grouping will also change. To handle this, many SDKs support hiding irrelevant stack trace frames. For example, the Python SDK will skip all stack frames with a local variable called `__traceback_hide__` set to _True_.

### Grouping By Exception

If the stack trace is not available, but exception information is, then the grouping will consider the `type` and `value` of the exception if both pieces of data are present on the event. This grouping is a lot less reliable because of changing error messages.

### Fallback Grouping

Grouping falls back to messages if the stack trace, `type`, and `value` are not available. When this happens, the grouping algorithm will try to use the message without any parameters. If that is not available, the grouping algorithm will use the full message attribute.

## Similar Issues Not Grouping

Have you ever had a set of similar-looking issues like this?
![Issues Dashboard](issues-dashboard.png)

Let's first understand how events group into an issue. The issue `testTypeIssue16` has 18 events that Sentry grouped into an issue because they share the same _fingerprint_.

If a set of issues in the Issues Stream looks similar, there is something that still differs: the stack trace, and therefore the fingerprint. Let's compare two similar looking issues side-by-side:

![Issues Dashboard](issue-stacktraces-comparison.png)

Notice the only difference is one had function testTypeIssue15 and the other had testTypeIssue14. This means the stack traces are not identical.

Sometimes two stack traces are the same function execution path but differ by one frame. This can be due to several things like middleware you've configured, node_modules, the framework itself, or library imports. To have greater control over which stack frames are included or excluded, see [Stack Trace Rules](/product/data-management-settings/event-grouping/stack-trace-rules/).

<Note>

Fortunately you can change the default grouping behavior to make certain issue types match on something other than stack trace. You can do this from both the **Server side** and the **SDK side**

</Note>

## Solutions

There are three different approaches for updating how events group into issues. The first approach is for merging together historical issues already created. We'll call this **Merging Similar Issues**. The second is for setting rules so next incoming issues will get grouped together. We'll call this **Fingerprint Rules**. The third is **SDK Side Fingerprinting**. The difference between SDK side and Server side is the data elements on the exception and stack traces which you can use for matching issues.

In **Merging Similar Issues** we'll see how historical issues can be merged together. No settings or configuration are required to do this.

In **Fingerprint Rules** we'll see how to set rules for new incoming issues of our choice to get grouped together by. This will not affect historical issues.

More on **SDK Side Fingerprinting** [here](/platform-redirect/?next=/usage/sdk-fingerprinting/).
